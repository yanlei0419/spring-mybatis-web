package seeker.test.Test20180712.ve;

public class NotInitialization{

    /**
     *
     *  加载-验证-准备-解析-初始化
     *  加载-连接-初始化  连接=验证-准备-解析
     *
     *  赋值是在 准备和 初始化做的
     *  准备阶段将类中的属性付初始值 0或者null
     *  初始化阶段 将执行类静态属性静态块的执行  按照代码顺序执行
     *  首先是 父类的静态属性 静态块
     *  然后是 子类的静态属性 静态块
     *  父类块
     *  父类的构造方法
     *  子类的块
     *  子类的构造方法
     *
     *  子类访问父类的静态属性必须初始化父类的静态字段和静态块不会初始化子类的静态字段和静态块
     *  对于静态字段，只有直接定义这个字段的类才会被初始化，
     *  因此通过其子类来引用父类中定义的静态字段，
     *  只会触发父类的初始化而不会触发子类的初始化。
     *
     *  1.通过子类引用父类的静态字段，不会导致子类初始化
     *  2.通过数组定义来引用类，不会触发此类的初始化
     *
     *  3.常量在编译阶段会存入调用类的常量池中，
     *  本质上并没有直接引用到定义常量的类，
     *  因此不会触发定义常量的类的初始化
     *
     *
     *
     *
     *  子类引用父类 代码常量属性时
     *  如果程序预先调过父类的常量属性
     *  子类在调用父类常量不会引发父类的 初始化
     *  否则即使子类调用父类的 常量也会 引发父类的初始化
     *
     *
     */
    public static void main(String[] args){
//        System.out.println(SubClass.b);
        System.out.println(SClass.value);
        System.out.println(SubClass.value);
    }
}